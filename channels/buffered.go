package channels

import "fmt"

func BufferedChannel() {
	ch := make(chan int, 5)

	for i := 0; i < 5; i++ {
		ch <- i
	}

	fmt.Println("Так как канал буферизованный, deadlock при чтении из единственной горутины не возникнет")
	fmt.Println("читаем только одно значение, а буфер состоит из пяти")
	fmt.Println("первое значение", <-ch)

	fmt.Println("вычитываем значения до исчерпания буфера")
	for i := 0; i < 4; i++ {
		<-ch
	}

	fmt.Println("если попытаться вычитать значение после исчерпания буфера, будет deadlock")
	// <-ch

	fmt.Println("Если попытаемся записать в канал больше значений, чем позволяет буфер, тоже будет deadlock")
	//for i := 0; i < 10; i++ {
	//	ch <- i
	//}

	fmt.Println(`Но если мы будем записывать в канал больше значений, чем позволяет буфер,
		но делать это в другой горутине, то заблокируется только она и deadlock не произойдет`)

	go func() {
		for i := 0; i < 10; i++ {
			ch <- i
		}
	}()
	fmt.Println("вычитываем все записанные значения")

	for i := 0; i < 10; i++ {
		<-ch
	}

	fmt.Println("Закрываем канал")
	close(ch)

	fmt.Println("При попытке записать в закрытый канал, получаем panic: send on closed channel")
	// ch <- 4

	fmt.Println("Читать из закрытого канала можно, получим нулевое значение")
	fmt.Println(<-ch)

	fmt.Println("Благодаря возможности читать из закрытого канала, можно проверять его на закрытость")
	if val, ok := <-ch; !ok {
		fmt.Println("Нулевое значение", val)
		fmt.Println("ok == false, канал закрыт")
	}
}
